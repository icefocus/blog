# postgreSQL 索引(一)索引介绍
### 总体介绍

索引是增强数据库性能的常用手段。索引的优点是可以帮助我们更快的查找和获取指定的行数据。但是如果数据库索引过度使用反而会拖累系统，所以应该更加有意识的使用索引。

假设我们有如下数据表：
```sql
CREATE TABLE test1  {

    id INTEGER,

    contest VARCHAR

}
```
程序可能需要如下查询：
```sql
SELECT content FROM test1 WHERE id = ?;
```
如果没有设置索引，数据库系统会对表 test1 进行全表索引来找到匹配的行。如果表test1有很多行，而我们的查询结果预计是只匹配很少的行（如上例子是1或0行），显然为例找到0或1行找遍整张表,不管有么有找到都会找遍整张表的效率是非常低的。但是如果我们在列id建立索引，我们可以更快的找到我们需要的行。

一个经典的类比是书的目录。假设你看过《笑傲江湖》电视剧对风清扬非常好奇，觉得电视剧没有交待清楚，想看下书上是怎么写的，把所有风清扬的描述片段全部找出来，于是你找到两本《笑傲江湖》，第一本没有目录，第二本有目录但只记录了风清扬名字出现的页码。对于第一本你只能一页一页的找（全表扫描）。第二本目录记录了风清扬名字出现的页码（索引建立在某一特定的列上），所以你能很快找出所有关于风清扬的内容。显然有目录会比没有目录快很多。

但是假设你用第二本只有风清扬索引的目录的书去查找任我行，显然目录帮助不到你，你还得一页一页的找（全表扫描）。这种情况类比于你查找没有建立索引的列。

例如：
```sql
SELECT content FROM test1 WHERE content LIKE 'foo'
```
创建索引

创建索引的语句为：
```sql
CREATE INDEX test1_id_index ON test1 (id);
```
删除索引
```sql
DROP INDEX test1_id_index;
```
当索引被创建以后，当向表中插入数据，索引会自动被触发更新，所以在表上创建非必须的索引会导致更多的开销，意味着插入数据会变慢。当更新索引后，进行查询时查询策略（查询机制为分为2个步骤，第一步执行查询规划，生成高效的查询的方式，第二步按第一步生成的查询策略执行查询，以后细讲）会决定使用全表扫描还是索引查询。也可以使用ANALYZE命令更新统计信息使查询策略更高效。一般不需要手动使用ANALYZE，统计信息系统会定时，或者触发更新，但需要时间和触发条件。（这部分以后细讲）。

更新、删除和join索引列也会优化查询，使查询更快。

给已有数据的表添加索引会需要一段长的时间，当然看数据量的大小了。但是在创建索引的时间内，查询还是可以执行的（多线程啦），但是插入、更新和删除会被阻塞。阻塞是为例保证索引正确行的设计，一边创建索引，一边又在改内容就像一边写代码，一边交互一直在改，还让不让写代码了。


 ------------------分割线---------------------

 索引系列
* [postgreSQL 索引(一)索引介绍](https://icefocus.github.io/blog/postgres/index_1)
* [postgreSQL 索引（二）类型介绍](https://icefocus.github.io/blog/postgres/index_2)
* [postgresSQL索引（三）联合索引--多列索引及多列复合索引和多列单独索引的选择](https://icefocus.github.io/blog/postgres/index_3)
* [postgresSQL索引(四)--索引和order by](https://icefocus.github.io/blog/postgres/index_4)

 ------------------分割线---------------------

如果觉得写的好，请关注我们的公众号

![qrcode_for_gh_f9cc78dcbc68_258.jpg](https://upload-images.jianshu.io/upload_images/8155989-d7cfe697173859ed.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)